#
# Autogenerated by Thrift Compiler (0.14.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ResultCode(object):
    SUCCESS = 1
    ERR_GENERIC = 2
    ERR_BUSY = 3
    ERR_INVALID_REQ = 4
    ERR_UNSUPPORTED = 5
    ERR_NOT_ACTIVATED = 6

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "ERR_GENERIC",
        3: "ERR_BUSY",
        4: "ERR_INVALID_REQ",
        5: "ERR_UNSUPPORTED",
        6: "ERR_NOT_ACTIVATED",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "ERR_GENERIC": 2,
        "ERR_BUSY": 3,
        "ERR_INVALID_REQ": 4,
        "ERR_UNSUPPORTED": 5,
        "ERR_NOT_ACTIVATED": 6,
    }


class ObjectDetectionEnv(object):
    NORMAL = 1
    BUSY = 2
    VERY_BUSY = 3

    _VALUES_TO_NAMES = {
        1: "NORMAL",
        2: "BUSY",
        3: "VERY_BUSY",
    }

    _NAMES_TO_VALUES = {
        "NORMAL": 1,
        "BUSY": 2,
        "VERY_BUSY": 3,
    }


class LineCrossCriteria(object):
    LINE_CROSS = 1
    LINE_SEGMENT_CROSS = 2
    LINE_CROSS_BOTH_DIR = 3
    LINE_SEGMENT_CROSS_BOTH_DIR = 4

    _VALUES_TO_NAMES = {
        1: "LINE_CROSS",
        2: "LINE_SEGMENT_CROSS",
        3: "LINE_CROSS_BOTH_DIR",
        4: "LINE_SEGMENT_CROSS_BOTH_DIR",
    }

    _NAMES_TO_VALUES = {
        "LINE_CROSS": 1,
        "LINE_SEGMENT_CROSS": 2,
        "LINE_CROSS_BOTH_DIR": 3,
        "LINE_SEGMENT_CROSS_BOTH_DIR": 4,
    }


class ObjectType(object):
    PERSON = 1

    _VALUES_TO_NAMES = {
        1: "PERSON",
    }

    _NAMES_TO_VALUES = {
        "PERSON": 1,
    }


class DetectionInputType(object):
    IMG_BUFFER_RAW = 1
    IMG_BUFFER_ENCODED = 2
    IMG_FILE_PATH = 3
    VID_FILE_PATH = 4

    _VALUES_TO_NAMES = {
        1: "IMG_BUFFER_RAW",
        2: "IMG_BUFFER_ENCODED",
        3: "IMG_FILE_PATH",
        4: "VID_FILE_PATH",
    }

    _NAMES_TO_VALUES = {
        "IMG_BUFFER_RAW": 1,
        "IMG_BUFFER_ENCODED": 2,
        "IMG_FILE_PATH": 3,
        "VID_FILE_PATH": 4,
    }


class ImageBufferFormat(object):
    RGB_HWC = 1

    _VALUES_TO_NAMES = {
        1: "RGB_HWC",
    }

    _NAMES_TO_VALUES = {
        "RGB_HWC": 1,
    }


class EncodedImageFormat(object):
    JPEG = 1

    _VALUES_TO_NAMES = {
        1: "JPEG",
    }

    _NAMES_TO_VALUES = {
        "JPEG": 1,
    }


class CrossDirection(object):
    UNKNOWN = 0
    CROSS_IN = 1
    CROSS_OUT = 2

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "CROSS_IN",
        2: "CROSS_OUT",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "CROSS_IN": 1,
        "CROSS_OUT": 2,
    }


class InitRequest(object):
    """
    Attributes:
     - license

    """


    def __init__(self, license=None,):
        self.license = license

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.license = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InitRequest')
        if self.license is not None:
            oprot.writeFieldBegin('license', TType.STRING, 1)
            oprot.writeString(self.license.encode('utf-8') if sys.version_info[0] == 2 else self.license)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionCapability(object):
    """
    Attributes:
     - numConcurrentSessions

    """


    def __init__(self, numConcurrentSessions=None,):
        self.numConcurrentSessions = numConcurrentSessions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.numConcurrentSessions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionCapability')
        if self.numConcurrentSessions is not None:
            oprot.writeFieldBegin('numConcurrentSessions', TType.I32, 1)
            oprot.writeI32(self.numConcurrentSessions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectorStatus(object):
    """
    Attributes:
     - version
     - apiVersion
     - initStatus
     - capability
     - activationChallenge

    """


    def __init__(self, version=None, apiVersion=None, initStatus=None, capability=None, activationChallenge=None,):
        self.version = version
        self.apiVersion = apiVersion
        self.initStatus = initStatus
        self.capability = capability
        self.activationChallenge = activationChallenge

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.apiVersion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.initStatus = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.capability = DetectionCapability()
                    self.capability.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.activationChallenge = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectorStatus')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.apiVersion is not None:
            oprot.writeFieldBegin('apiVersion', TType.STRING, 2)
            oprot.writeString(self.apiVersion.encode('utf-8') if sys.version_info[0] == 2 else self.apiVersion)
            oprot.writeFieldEnd()
        if self.initStatus is not None:
            oprot.writeFieldBegin('initStatus', TType.I32, 3)
            oprot.writeI32(self.initStatus)
            oprot.writeFieldEnd()
        if self.capability is not None:
            oprot.writeFieldBegin('capability', TType.STRUCT, 4)
            self.capability.write(oprot)
            oprot.writeFieldEnd()
        if self.activationChallenge is not None:
            oprot.writeFieldBegin('activationChallenge', TType.STRING, 5)
            oprot.writeString(self.activationChallenge.encode('utf-8') if sys.version_info[0] == 2 else self.activationChallenge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ObjectDetectionSettings(object):
    """
    Attributes:
     - enabled
     - env
     - objectType
     - detectOnlyMovingObjects

    """


    def __init__(self, enabled=None, env=None, objectType=None, detectOnlyMovingObjects=None,):
        self.enabled = enabled
        self.env = env
        self.objectType = objectType
        self.detectOnlyMovingObjects = detectOnlyMovingObjects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.env = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.objectType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.detectOnlyMovingObjects = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ObjectDetectionSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.I32, 2)
            oprot.writeI32(self.env)
            oprot.writeFieldEnd()
        if self.objectType is not None:
            oprot.writeFieldBegin('objectType', TType.I32, 3)
            oprot.writeI32(self.objectType)
            oprot.writeFieldEnd()
        if self.detectOnlyMovingObjects is not None:
            oprot.writeFieldBegin('detectOnlyMovingObjects', TType.BOOL, 4)
            oprot.writeBool(self.detectOnlyMovingObjects)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionArea(object):
    """
    Attributes:
     - top
     - left
     - bottom
     - right
     - name

    """


    def __init__(self, top=None, left=None, bottom=None, right=None, name=None,):
        self.top = top
        self.left = left
        self.bottom = bottom
        self.right = right
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.top = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.left = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.bottom = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.right = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionArea')
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.DOUBLE, 1)
            oprot.writeDouble(self.top)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.DOUBLE, 2)
            oprot.writeDouble(self.left)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.DOUBLE, 3)
            oprot.writeDouble(self.bottom)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.DOUBLE, 4)
            oprot.writeDouble(self.right)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 5)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionAreaSettings(object):
    """
    Attributes:
     - enabled
     - areas

    """


    def __init__(self, enabled=None, areas=None,):
        self.enabled = enabled
        self.areas = areas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.areas = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = DetectionArea()
                        _elem5.read(iprot)
                        self.areas.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionAreaSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.areas is not None:
            oprot.writeFieldBegin('areas', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.areas))
            for iter6 in self.areas:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NormPoint(object):
    """
    Attributes:
     - x
     - y

    """


    def __init__(self, x=None, y=None,):
        self.x = x
        self.y = y

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NormPoint')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceSettings(object):
    """
    Attributes:
     - enabled
     - groundBoundary
     - minSeparation

    """


    def __init__(self, enabled=None, groundBoundary=None, minSeparation=None,):
        self.enabled = enabled
        self.groundBoundary = groundBoundary
        self.minSeparation = minSeparation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.groundBoundary = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = NormPoint()
                        _elem12.read(iprot)
                        self.groundBoundary.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.minSeparation = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = NormPoint()
                        _elem18.read(iprot)
                        self.minSeparation.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.groundBoundary is not None:
            oprot.writeFieldBegin('groundBoundary', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.groundBoundary))
            for iter19 in self.groundBoundary:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.minSeparation is not None:
            oprot.writeFieldBegin('minSeparation', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.minSeparation))
            for iter20 in self.minSeparation:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossSettings(object):
    """
    Attributes:
     - enabled
     - boundary
     - inPoint
     - crossCriteria

    """


    def __init__(self, enabled=None, boundary=None, inPoint=None, crossCriteria=None,):
        self.enabled = enabled
        self.boundary = boundary
        self.inPoint = inPoint
        self.crossCriteria = crossCriteria

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.boundary = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = NormPoint()
                        _elem26.read(iprot)
                        self.boundary.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.inPoint = NormPoint()
                    self.inPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.crossCriteria = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.boundary is not None:
            oprot.writeFieldBegin('boundary', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.boundary))
            for iter27 in self.boundary:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inPoint is not None:
            oprot.writeFieldBegin('inPoint', TType.STRUCT, 3)
            self.inPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.crossCriteria is not None:
            oprot.writeFieldBegin('crossCriteria', TType.I32, 4)
            oprot.writeI32(self.crossCriteria)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MaskDetectionSettings(object):
    """
    Attributes:
     - enabled

    """


    def __init__(self, enabled=None,):
        self.enabled = enabled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MaskDetectionSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionSettings(object):
    """
    Attributes:
     - objSettings
     - sdSettings
     - detAreaSettings
     - lineCrossSettings
     - maskSettings

    """


    def __init__(self, objSettings=None, sdSettings=None, detAreaSettings=None, lineCrossSettings=None, maskSettings=None,):
        self.objSettings = objSettings
        self.sdSettings = sdSettings
        self.detAreaSettings = detAreaSettings
        self.lineCrossSettings = lineCrossSettings
        self.maskSettings = maskSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.objSettings = ObjectDetectionSettings()
                    self.objSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sdSettings = SocialDistanceSettings()
                    self.sdSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.detAreaSettings = DetectionAreaSettings()
                    self.detAreaSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lineCrossSettings = LineCrossSettings()
                    self.lineCrossSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.maskSettings = MaskDetectionSettings()
                    self.maskSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionSettings')
        if self.objSettings is not None:
            oprot.writeFieldBegin('objSettings', TType.STRUCT, 1)
            self.objSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.sdSettings is not None:
            oprot.writeFieldBegin('sdSettings', TType.STRUCT, 2)
            self.sdSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.detAreaSettings is not None:
            oprot.writeFieldBegin('detAreaSettings', TType.STRUCT, 3)
            self.detAreaSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.lineCrossSettings is not None:
            oprot.writeFieldBegin('lineCrossSettings', TType.STRUCT, 4)
            self.lineCrossSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.maskSettings is not None:
            oprot.writeFieldBegin('maskSettings', TType.STRUCT, 5)
            self.maskSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionSession(object):
    """
    Attributes:
     - id
     - detectionSettings

    """


    def __init__(self, id=None, detectionSettings=None,):
        self.id = id
        self.detectionSettings = detectionSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.detectionSettings = DetectionSettings()
                    self.detectionSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionSession')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.detectionSettings is not None:
            oprot.writeFieldBegin('detectionSettings', TType.STRUCT, 2)
            self.detectionSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RawImageInput(object):
    """
    Attributes:
     - width
     - height
     - format
     - buffer

    """


    def __init__(self, width=None, height=None, format=None, buffer=None,):
        self.width = width
        self.height = height
        self.format = format
        self.buffer = buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.width = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.height = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RawImageInput')
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I16, 1)
            oprot.writeI16(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I16, 2)
            oprot.writeI16(self.height)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.I32, 3)
            oprot.writeI32(self.format)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 4)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncodedImageInput(object):
    """
    Attributes:
     - format
     - buffer
     - bufferLength

    """


    def __init__(self, format=None, buffer=None, bufferLength=None,):
        self.format = format
        self.buffer = buffer
        self.bufferLength = bufferLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.bufferLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncodedImageInput')
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.I32, 1)
            oprot.writeI32(self.format)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        if self.bufferLength is not None:
            oprot.writeFieldBegin('bufferLength', TType.I32, 3)
            oprot.writeI32(self.bufferLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImageFileInput(object):
    """
    Attributes:
     - filename

    """


    def __init__(self, filename=None,):
        self.filename = filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ImageFileInput')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VideoFileInput(object):
    """
    Attributes:
     - filename
     - processFps

    """


    def __init__(self, filename=None, processFps=None,):
        self.filename = filename
        self.processFps = processFps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.processFps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VideoFileInput')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.processFps is not None:
            oprot.writeFieldBegin('processFps', TType.I32, 2)
            oprot.writeI32(self.processFps)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InputParams(object):
    """
    Attributes:
     - rawImageInput
     - encImageInput
     - imgFileInput
     - vidFileInput

    """


    def __init__(self, rawImageInput=None, encImageInput=None, imgFileInput=None, vidFileInput=None,):
        self.rawImageInput = rawImageInput
        self.encImageInput = encImageInput
        self.imgFileInput = imgFileInput
        self.vidFileInput = vidFileInput

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rawImageInput = RawImageInput()
                    self.rawImageInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.encImageInput = EncodedImageInput()
                    self.encImageInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.imgFileInput = ImageFileInput()
                    self.imgFileInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.vidFileInput = VideoFileInput()
                    self.vidFileInput.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InputParams')
        if self.rawImageInput is not None:
            oprot.writeFieldBegin('rawImageInput', TType.STRUCT, 1)
            self.rawImageInput.write(oprot)
            oprot.writeFieldEnd()
        if self.encImageInput is not None:
            oprot.writeFieldBegin('encImageInput', TType.STRUCT, 2)
            self.encImageInput.write(oprot)
            oprot.writeFieldEnd()
        if self.imgFileInput is not None:
            oprot.writeFieldBegin('imgFileInput', TType.STRUCT, 3)
            self.imgFileInput.write(oprot)
            oprot.writeFieldEnd()
        if self.vidFileInput is not None:
            oprot.writeFieldBegin('vidFileInput', TType.STRUCT, 4)
            self.vidFileInput.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionInput(object):
    """
    Attributes:
     - type
     - params

    """


    def __init__(self, type=None, params=None,):
        self.type = type
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = InputParams()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionInput')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectedObject(object):
    """
    Attributes:
     - name
     - objectId
     - top
     - left
     - bottom
     - right
     - frameIndex
     - confidence
     - direction

    """


    def __init__(self, name=None, objectId=None, top=None, left=None, bottom=None, right=None, frameIndex=None, confidence=None, direction=None,):
        self.name = name
        self.objectId = objectId
        self.top = top
        self.left = left
        self.bottom = bottom
        self.right = right
        self.frameIndex = frameIndex
        self.confidence = confidence
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.objectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.top = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.left = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.bottom = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.right = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.frameIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectedObject')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.objectId is not None:
            oprot.writeFieldBegin('objectId', TType.I32, 2)
            oprot.writeI32(self.objectId)
            oprot.writeFieldEnd()
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.DOUBLE, 3)
            oprot.writeDouble(self.top)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.DOUBLE, 4)
            oprot.writeDouble(self.left)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.DOUBLE, 5)
            oprot.writeDouble(self.bottom)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.DOUBLE, 6)
            oprot.writeDouble(self.right)
            oprot.writeFieldEnd()
        if self.frameIndex is not None:
            oprot.writeFieldBegin('frameIndex', TType.I32, 7)
            oprot.writeI32(self.frameIndex)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 8)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 9)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ObjectDetectionResult(object):
    """
    Attributes:
     - objects

    """


    def __init__(self, objects=None,):
        self.objects = objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = DetectedObject()
                        _elem33.read(iprot)
                        self.objects.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ObjectDetectionResult')
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.objects))
            for iter34 in self.objects:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceViolation(object):
    """
    Attributes:
     - first
     - second

    """


    def __init__(self, first=None, second=None,):
        self.first = first
        self.second = second

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.first = DetectedObject()
                    self.first.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.second = DetectedObject()
                    self.second.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceViolation')
        if self.first is not None:
            oprot.writeFieldBegin('first', TType.STRUCT, 1)
            self.first.write(oprot)
            oprot.writeFieldEnd()
        if self.second is not None:
            oprot.writeFieldBegin('second', TType.STRUCT, 2)
            self.second.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceResult(object):
    """
    Attributes:
     - violations

    """


    def __init__(self, violations=None,):
        self.violations = violations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.violations = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = SocialDistanceViolation()
                        _elem40.read(iprot)
                        self.violations.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceResult')
        if self.violations is not None:
            oprot.writeFieldBegin('violations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.violations))
            for iter41 in self.violations:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossViolation(object):
    """
    Attributes:
     - first
     - second

    """


    def __init__(self, first=None, second=None,):
        self.first = first
        self.second = second

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.first = DetectedObject()
                    self.first.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.second = DetectedObject()
                    self.second.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossViolation')
        if self.first is not None:
            oprot.writeFieldBegin('first', TType.STRUCT, 1)
            self.first.write(oprot)
            oprot.writeFieldEnd()
        if self.second is not None:
            oprot.writeFieldBegin('second', TType.STRUCT, 2)
            self.second.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossDetectionResult(object):
    """
    Attributes:
     - violations

    """


    def __init__(self, violations=None,):
        self.violations = violations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.violations = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = LineCrossViolation()
                        _elem47.read(iprot)
                        self.violations.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossDetectionResult')
        if self.violations is not None:
            oprot.writeFieldBegin('violations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.violations))
            for iter48 in self.violations:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MaskDetectionResult(object):
    """
    Attributes:
     - objects

    """


    def __init__(self, objects=None,):
        self.objects = objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = DetectedObject()
                        _elem54.read(iprot)
                        self.objects.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MaskDetectionResult')
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.objects))
            for iter55 in self.objects:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionOutput(object):
    """
    Attributes:
     - status
     - objDetResult
     - socialDetResult
     - lineCrossResult
     - maskDetResult

    """


    def __init__(self, status=None, objDetResult=None, socialDetResult=None, lineCrossResult=None, maskDetResult=None,):
        self.status = status
        self.objDetResult = objDetResult
        self.socialDetResult = socialDetResult
        self.lineCrossResult = lineCrossResult
        self.maskDetResult = maskDetResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.objDetResult = ObjectDetectionResult()
                    self.objDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.socialDetResult = SocialDistanceResult()
                    self.socialDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lineCrossResult = LineCrossDetectionResult()
                    self.lineCrossResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.maskDetResult = MaskDetectionResult()
                    self.maskDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionOutput')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.objDetResult is not None:
            oprot.writeFieldBegin('objDetResult', TType.STRUCT, 2)
            self.objDetResult.write(oprot)
            oprot.writeFieldEnd()
        if self.socialDetResult is not None:
            oprot.writeFieldBegin('socialDetResult', TType.STRUCT, 3)
            self.socialDetResult.write(oprot)
            oprot.writeFieldEnd()
        if self.lineCrossResult is not None:
            oprot.writeFieldBegin('lineCrossResult', TType.STRUCT, 4)
            self.lineCrossResult.write(oprot)
            oprot.writeFieldEnd()
        if self.maskDetResult is not None:
            oprot.writeFieldBegin('maskDetResult', TType.STRUCT, 5)
            self.maskDetResult.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InitRequest)
InitRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'license', 'UTF8', None, ),  # 1
)
all_structs.append(DetectionCapability)
DetectionCapability.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'numConcurrentSessions', None, None, ),  # 1
)
all_structs.append(DetectorStatus)
DetectorStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'apiVersion', 'UTF8', None, ),  # 2
    (3, TType.I32, 'initStatus', None, None, ),  # 3
    (4, TType.STRUCT, 'capability', [DetectionCapability, None], None, ),  # 4
    (5, TType.STRING, 'activationChallenge', 'UTF8', None, ),  # 5
)
all_structs.append(ObjectDetectionSettings)
ObjectDetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.I32, 'env', None, None, ),  # 2
    (3, TType.I32, 'objectType', None, None, ),  # 3
    (4, TType.BOOL, 'detectOnlyMovingObjects', None, None, ),  # 4
)
all_structs.append(DetectionArea)
DetectionArea.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'top', None, None, ),  # 1
    (2, TType.DOUBLE, 'left', None, None, ),  # 2
    (3, TType.DOUBLE, 'bottom', None, None, ),  # 3
    (4, TType.DOUBLE, 'right', None, None, ),  # 4
    (5, TType.STRING, 'name', 'UTF8', None, ),  # 5
)
all_structs.append(DetectionAreaSettings)
DetectionAreaSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'areas', (TType.STRUCT, [DetectionArea, None], False), None, ),  # 2
)
all_structs.append(NormPoint)
NormPoint.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
)
all_structs.append(SocialDistanceSettings)
SocialDistanceSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'groundBoundary', (TType.STRUCT, [NormPoint, None], False), None, ),  # 2
    (3, TType.LIST, 'minSeparation', (TType.STRUCT, [NormPoint, None], False), None, ),  # 3
)
all_structs.append(LineCrossSettings)
LineCrossSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'boundary', (TType.STRUCT, [NormPoint, None], False), None, ),  # 2
    (3, TType.STRUCT, 'inPoint', [NormPoint, None], None, ),  # 3
    (4, TType.I32, 'crossCriteria', None, None, ),  # 4
)
all_structs.append(MaskDetectionSettings)
MaskDetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
)
all_structs.append(DetectionSettings)
DetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'objSettings', [ObjectDetectionSettings, None], None, ),  # 1
    (2, TType.STRUCT, 'sdSettings', [SocialDistanceSettings, None], None, ),  # 2
    (3, TType.STRUCT, 'detAreaSettings', [DetectionAreaSettings, None], None, ),  # 3
    (4, TType.STRUCT, 'lineCrossSettings', [LineCrossSettings, None], None, ),  # 4
    (5, TType.STRUCT, 'maskSettings', [MaskDetectionSettings, None], None, ),  # 5
)
all_structs.append(DetectionSession)
DetectionSession.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRUCT, 'detectionSettings', [DetectionSettings, None], None, ),  # 2
)
all_structs.append(RawImageInput)
RawImageInput.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'width', None, None, ),  # 1
    (2, TType.I16, 'height', None, None, ),  # 2
    (3, TType.I32, 'format', None, None, ),  # 3
    (4, TType.STRING, 'buffer', 'BINARY', None, ),  # 4
)
all_structs.append(EncodedImageInput)
EncodedImageInput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'format', None, None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
    (3, TType.I32, 'bufferLength', None, None, ),  # 3
)
all_structs.append(ImageFileInput)
ImageFileInput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
)
all_structs.append(VideoFileInput)
VideoFileInput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
    (2, TType.I32, 'processFps', None, None, ),  # 2
)
all_structs.append(InputParams)
InputParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rawImageInput', [RawImageInput, None], None, ),  # 1
    (2, TType.STRUCT, 'encImageInput', [EncodedImageInput, None], None, ),  # 2
    (3, TType.STRUCT, 'imgFileInput', [ImageFileInput, None], None, ),  # 3
    (4, TType.STRUCT, 'vidFileInput', [VideoFileInput, None], None, ),  # 4
)
all_structs.append(DetectionInput)
DetectionInput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'params', [InputParams, None], None, ),  # 2
)
all_structs.append(DetectedObject)
DetectedObject.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'objectId', None, None, ),  # 2
    (3, TType.DOUBLE, 'top', None, None, ),  # 3
    (4, TType.DOUBLE, 'left', None, None, ),  # 4
    (5, TType.DOUBLE, 'bottom', None, None, ),  # 5
    (6, TType.DOUBLE, 'right', None, None, ),  # 6
    (7, TType.I32, 'frameIndex', None, None, ),  # 7
    (8, TType.DOUBLE, 'confidence', None, None, ),  # 8
    (9, TType.I32, 'direction', None, None, ),  # 9
)
all_structs.append(ObjectDetectionResult)
ObjectDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'objects', (TType.STRUCT, [DetectedObject, None], False), None, ),  # 1
)
all_structs.append(SocialDistanceViolation)
SocialDistanceViolation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'first', [DetectedObject, None], None, ),  # 1
    (2, TType.STRUCT, 'second', [DetectedObject, None], None, ),  # 2
)
all_structs.append(SocialDistanceResult)
SocialDistanceResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'violations', (TType.STRUCT, [SocialDistanceViolation, None], False), None, ),  # 1
)
all_structs.append(LineCrossViolation)
LineCrossViolation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'first', [DetectedObject, None], None, ),  # 1
    (2, TType.STRUCT, 'second', [DetectedObject, None], None, ),  # 2
)
all_structs.append(LineCrossDetectionResult)
LineCrossDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'violations', (TType.STRUCT, [LineCrossViolation, None], False), None, ),  # 1
)
all_structs.append(MaskDetectionResult)
MaskDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'objects', (TType.STRUCT, [DetectedObject, None], False), None, ),  # 1
)
all_structs.append(DetectionOutput)
DetectionOutput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRUCT, 'objDetResult', [ObjectDetectionResult, None], None, ),  # 2
    (3, TType.STRUCT, 'socialDetResult', [SocialDistanceResult, None], None, ),  # 3
    (4, TType.STRUCT, 'lineCrossResult', [LineCrossDetectionResult, None], None, ),  # 4
    (5, TType.STRUCT, 'maskDetResult', [MaskDetectionResult, None], None, ),  # 5
)
fix_spec(all_structs)
del all_structs
