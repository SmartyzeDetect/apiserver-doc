#
# Autogenerated by Thrift Compiler (0.14.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class ResultCode(object):
    """
    Result codes for APIs

    """
    SUCCESS = 1
    ERR_GENERIC = 2
    ERR_BUSY = 3
    ERR_INVALID_REQ = 4
    ERR_UNSUPPORTED = 5
    ERR_NOT_ACTIVATED = 6

    _VALUES_TO_NAMES = {
        1: "SUCCESS",
        2: "ERR_GENERIC",
        3: "ERR_BUSY",
        4: "ERR_INVALID_REQ",
        5: "ERR_UNSUPPORTED",
        6: "ERR_NOT_ACTIVATED",
    }

    _NAMES_TO_VALUES = {
        "SUCCESS": 1,
        "ERR_GENERIC": 2,
        "ERR_BUSY": 3,
        "ERR_INVALID_REQ": 4,
        "ERR_UNSUPPORTED": 5,
        "ERR_NOT_ACTIVATED": 6,
    }


class ObjectDetectionEnv(object):
    """
    Object detection accuracy/speed setting

    """
    NORMAL = 1
    BUSY = 2
    VERY_BUSY = 3

    _VALUES_TO_NAMES = {
        1: "NORMAL",
        2: "BUSY",
        3: "VERY_BUSY",
    }

    _NAMES_TO_VALUES = {
        "NORMAL": 1,
        "BUSY": 2,
        "VERY_BUSY": 3,
    }


class LineCrossCriteria(object):
    """
    Line cross criteria for line cross settings

    """
    LINE_CROSS = 1
    LINE_SEGMENT_CROSS = 2
    LINE_CROSS_BOTH_DIR = 3
    LINE_SEGMENT_CROSS_BOTH_DIR = 4

    _VALUES_TO_NAMES = {
        1: "LINE_CROSS",
        2: "LINE_SEGMENT_CROSS",
        3: "LINE_CROSS_BOTH_DIR",
        4: "LINE_SEGMENT_CROSS_BOTH_DIR",
    }

    _NAMES_TO_VALUES = {
        "LINE_CROSS": 1,
        "LINE_SEGMENT_CROSS": 2,
        "LINE_CROSS_BOTH_DIR": 3,
        "LINE_SEGMENT_CROSS_BOTH_DIR": 4,
    }


class ObjectType(object):
    """
    Detection object type

    """
    PERSON = 1

    _VALUES_TO_NAMES = {
        1: "PERSON",
    }

    _NAMES_TO_VALUES = {
        "PERSON": 1,
    }


class DetectionInputType(object):
    """
    Detection input type

    """
    IMG_BUFFER_RAW = 1
    IMG_BUFFER_ENCODED = 2
    IMG_FILE_PATH = 3
    VID_FILE_PATH = 4

    _VALUES_TO_NAMES = {
        1: "IMG_BUFFER_RAW",
        2: "IMG_BUFFER_ENCODED",
        3: "IMG_FILE_PATH",
        4: "VID_FILE_PATH",
    }

    _NAMES_TO_VALUES = {
        "IMG_BUFFER_RAW": 1,
        "IMG_BUFFER_ENCODED": 2,
        "IMG_FILE_PATH": 3,
        "VID_FILE_PATH": 4,
    }


class ImageBufferFormat(object):
    """
    Raw image pixel format

    """
    RGB_HWC = 1

    _VALUES_TO_NAMES = {
        1: "RGB_HWC",
    }

    _NAMES_TO_VALUES = {
        "RGB_HWC": 1,
    }


class EncodedImageFormat(object):
    """
    Encoded image format type

    """
    JPEG = 1

    _VALUES_TO_NAMES = {
        1: "JPEG",
    }

    _NAMES_TO_VALUES = {
        "JPEG": 1,
    }


class CrossDirection(object):
    """
    Line cross direction

    """
    UNKNOWN = 0
    CROSS_IN = 1
    CROSS_OUT = 2

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "CROSS_IN",
        2: "CROSS_OUT",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "CROSS_IN": 1,
        "CROSS_OUT": 2,
    }


class InitRequest(object):
    """
    API server initialization request

    Attributes:
     - license: License for activation

    """


    def __init__(self, license=None,):
        self.license = license

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.license = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InitRequest')
        if self.license is not None:
            oprot.writeFieldBegin('license', TType.STRING, 1)
            oprot.writeString(self.license.encode('utf-8') if sys.version_info[0] == 2 else self.license)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionCapability(object):
    """
    Detection capabilities of instance where API server is running

    Attributes:
     - numConcurrentSessions: Number of possible concurrent detection sessions

    """


    def __init__(self, numConcurrentSessions=None,):
        self.numConcurrentSessions = numConcurrentSessions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.numConcurrentSessions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionCapability')
        if self.numConcurrentSessions is not None:
            oprot.writeFieldBegin('numConcurrentSessions', TType.I32, 1)
            oprot.writeI32(self.numConcurrentSessions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectorStatus(object):
    """
    API server status

    Attributes:
     - version: S/W version of the server
     - apiVersion: API version of the server
     - initStatus: Initialization status of the server
     - capability: Detection capability of server instance
     - activationChallenge: Activation challenge for license in offline mode

    """


    def __init__(self, version=None, apiVersion=None, initStatus=None, capability=None, activationChallenge=None,):
        self.version = version
        self.apiVersion = apiVersion
        self.initStatus = initStatus
        self.capability = capability
        self.activationChallenge = activationChallenge

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.apiVersion = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.initStatus = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.capability = DetectionCapability()
                    self.capability.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.activationChallenge = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectorStatus')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.apiVersion is not None:
            oprot.writeFieldBegin('apiVersion', TType.STRING, 2)
            oprot.writeString(self.apiVersion.encode('utf-8') if sys.version_info[0] == 2 else self.apiVersion)
            oprot.writeFieldEnd()
        if self.initStatus is not None:
            oprot.writeFieldBegin('initStatus', TType.I32, 3)
            oprot.writeI32(self.initStatus)
            oprot.writeFieldEnd()
        if self.capability is not None:
            oprot.writeFieldBegin('capability', TType.STRUCT, 4)
            self.capability.write(oprot)
            oprot.writeFieldEnd()
        if self.activationChallenge is not None:
            oprot.writeFieldBegin('activationChallenge', TType.STRING, 5)
            oprot.writeString(self.activationChallenge.encode('utf-8') if sys.version_info[0] == 2 else self.activationChallenge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ObjectDetectionSettings(object):
    """
    Settings for object detection

    Attributes:
     - enabled: whether object detection is enabled
     - env: object detection accuracy/speed setting
     - objectType: object detection type
     - detectOnlyMovingObjects: whether to ignore static objects

    """


    def __init__(self, enabled=None, env=None, objectType=None, detectOnlyMovingObjects=None,):
        self.enabled = enabled
        self.env = env
        self.objectType = objectType
        self.detectOnlyMovingObjects = detectOnlyMovingObjects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.env = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.objectType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.detectOnlyMovingObjects = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ObjectDetectionSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.env is not None:
            oprot.writeFieldBegin('env', TType.I32, 2)
            oprot.writeI32(self.env)
            oprot.writeFieldEnd()
        if self.objectType is not None:
            oprot.writeFieldBegin('objectType', TType.I32, 3)
            oprot.writeI32(self.objectType)
            oprot.writeFieldEnd()
        if self.detectOnlyMovingObjects is not None:
            oprot.writeFieldBegin('detectOnlyMovingObjects', TType.BOOL, 4)
            oprot.writeBool(self.detectOnlyMovingObjects)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionArea(object):
    """
    Object detection area descriptor

    Attributes:
     - top: top left y co-ordinate normalized [0, 1]
     - left: top left x co-ordinate normalized [0, 1]
     - bottom: bottom right y co-ordinate normalized [0, 1]
     - right: bottom right x co-ordinate normalized [0, 1]
     - name: friendly name of the area

    """


    def __init__(self, top=None, left=None, bottom=None, right=None, name=None,):
        self.top = top
        self.left = left
        self.bottom = bottom
        self.right = right
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.top = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.left = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.bottom = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.right = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionArea')
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.DOUBLE, 1)
            oprot.writeDouble(self.top)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.DOUBLE, 2)
            oprot.writeDouble(self.left)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.DOUBLE, 3)
            oprot.writeDouble(self.bottom)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.DOUBLE, 4)
            oprot.writeDouble(self.right)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 5)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionAreaSettings(object):
    """
    Detection area settings

    Attributes:
     - enabled: whether object detection within areas only is enabled
     - areas: list of object detection areas (max of 2)

    """


    def __init__(self, enabled=None, areas=None,):
        self.enabled = enabled
        self.areas = areas

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.areas = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = DetectionArea()
                        _elem5.read(iprot)
                        self.areas.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionAreaSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.areas is not None:
            oprot.writeFieldBegin('areas', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.areas))
            for iter6 in self.areas:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class NormPoint(object):
    """
    Normalized co-ordinate descriptor
    Co-ordinate system: Top left of image is (0,0)
    x increases from left to right
    y increases from top to bottom

    Attributes:
     - x: x co-ordinate normalized [0,1]
     - y: y co-ordinate normalized [0,1]

    """


    def __init__(self, x=None, y=None,):
        self.x = x
        self.y = y

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.x = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.y = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('NormPoint')
        if self.x is not None:
            oprot.writeFieldBegin('x', TType.DOUBLE, 1)
            oprot.writeDouble(self.x)
            oprot.writeFieldEnd()
        if self.y is not None:
            oprot.writeFieldBegin('y', TType.DOUBLE, 2)
            oprot.writeDouble(self.y)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.x is None:
            raise TProtocolException(message='Required field x is unset!')
        if self.y is None:
            raise TProtocolException(message='Required field y is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceSettings(object):
    """
    Social distancing detection settings

    Attributes:
     - enabled: whether social distancing violation detection is enabled
     - groundBoundary: 4 points indicating a rectangular area on the ground in view
     - minSeparation: 2 points indicating the minimum separation on the ground

    """


    def __init__(self, enabled=None, groundBoundary=None, minSeparation=None,):
        self.enabled = enabled
        self.groundBoundary = groundBoundary
        self.minSeparation = minSeparation

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.groundBoundary = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = NormPoint()
                        _elem12.read(iprot)
                        self.groundBoundary.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.minSeparation = []
                    (_etype16, _size13) = iprot.readListBegin()
                    for _i17 in range(_size13):
                        _elem18 = NormPoint()
                        _elem18.read(iprot)
                        self.minSeparation.append(_elem18)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.groundBoundary is not None:
            oprot.writeFieldBegin('groundBoundary', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.groundBoundary))
            for iter19 in self.groundBoundary:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.minSeparation is not None:
            oprot.writeFieldBegin('minSeparation', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.minSeparation))
            for iter20 in self.minSeparation:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossSettings(object):
    """
    Line crossing detection settings
    Note: A line cross is considered using the bottom middle point
    of an object bounding box as reference

    Attributes:
     - enabled: whether line crossing detection is enabled
     - boundary: 2 points on the ground in view indicating the line to monitor
     - inPoint: 1 point denoting the 'in' side of the line
     - crossCriteria: Line cross mode to detect

    """


    def __init__(self, enabled=None, boundary=None, inPoint=None, crossCriteria=None,):
        self.enabled = enabled
        self.boundary = boundary
        self.inPoint = inPoint
        self.crossCriteria = crossCriteria

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.boundary = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = NormPoint()
                        _elem26.read(iprot)
                        self.boundary.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.inPoint = NormPoint()
                    self.inPoint.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.crossCriteria = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.boundary is not None:
            oprot.writeFieldBegin('boundary', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.boundary))
            for iter27 in self.boundary:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.inPoint is not None:
            oprot.writeFieldBegin('inPoint', TType.STRUCT, 3)
            self.inPoint.write(oprot)
            oprot.writeFieldEnd()
        if self.crossCriteria is not None:
            oprot.writeFieldBegin('crossCriteria', TType.I32, 4)
            oprot.writeI32(self.crossCriteria)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MaskDetectionSettings(object):
    """
    Mask detection settings

    Attributes:
     - enabled: whether mask detection is enabled

    """


    def __init__(self, enabled=None,):
        self.enabled = enabled

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MaskDetectionSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlprSettings(object):
    """
    Automatic License Plate Recognition (ALPR) settings

    Attributes:
     - enabled: whether ALPR is enabled
     - region: region code to be used for ALPR
     - skipVehicleCheck: whether to skip vehicle check for license plate detection
     - presetMode: preset mode specifying speed/accuracy tradeoff - default is 'medium'

    """


    def __init__(self, enabled=None, region=None, skipVehicleCheck=None, presetMode=None,):
        self.enabled = enabled
        self.region = region
        self.skipVehicleCheck = skipVehicleCheck
        self.presetMode = presetMode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.enabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.region = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.skipVehicleCheck = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.presetMode = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlprSettings')
        if self.enabled is not None:
            oprot.writeFieldBegin('enabled', TType.BOOL, 1)
            oprot.writeBool(self.enabled)
            oprot.writeFieldEnd()
        if self.region is not None:
            oprot.writeFieldBegin('region', TType.STRING, 2)
            oprot.writeString(self.region.encode('utf-8') if sys.version_info[0] == 2 else self.region)
            oprot.writeFieldEnd()
        if self.skipVehicleCheck is not None:
            oprot.writeFieldBegin('skipVehicleCheck', TType.BOOL, 3)
            oprot.writeBool(self.skipVehicleCheck)
            oprot.writeFieldEnd()
        if self.presetMode is not None:
            oprot.writeFieldBegin('presetMode', TType.STRING, 4)
            oprot.writeString(self.presetMode.encode('utf-8') if sys.version_info[0] == 2 else self.presetMode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.enabled is None:
            raise TProtocolException(message='Required field enabled is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionSettings(object):
    """
    Detection settings for a session

    Attributes:
     - objSettings: Object detection settings
     - sdSettings: Social distancing detection settings
     - detAreaSettings: Area detection settings
     - lineCrossSettings: Line cross settings
     - maskSettings: Mask detection settings
     - alprSettings: ALPR settings

    """


    def __init__(self, objSettings=None, sdSettings=None, detAreaSettings=None, lineCrossSettings=None, maskSettings=None, alprSettings=None,):
        self.objSettings = objSettings
        self.sdSettings = sdSettings
        self.detAreaSettings = detAreaSettings
        self.lineCrossSettings = lineCrossSettings
        self.maskSettings = maskSettings
        self.alprSettings = alprSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.objSettings = ObjectDetectionSettings()
                    self.objSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sdSettings = SocialDistanceSettings()
                    self.sdSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.detAreaSettings = DetectionAreaSettings()
                    self.detAreaSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lineCrossSettings = LineCrossSettings()
                    self.lineCrossSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.maskSettings = MaskDetectionSettings()
                    self.maskSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.alprSettings = AlprSettings()
                    self.alprSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionSettings')
        if self.objSettings is not None:
            oprot.writeFieldBegin('objSettings', TType.STRUCT, 1)
            self.objSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.sdSettings is not None:
            oprot.writeFieldBegin('sdSettings', TType.STRUCT, 2)
            self.sdSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.detAreaSettings is not None:
            oprot.writeFieldBegin('detAreaSettings', TType.STRUCT, 3)
            self.detAreaSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.lineCrossSettings is not None:
            oprot.writeFieldBegin('lineCrossSettings', TType.STRUCT, 4)
            self.lineCrossSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.maskSettings is not None:
            oprot.writeFieldBegin('maskSettings', TType.STRUCT, 5)
            self.maskSettings.write(oprot)
            oprot.writeFieldEnd()
        if self.alprSettings is not None:
            oprot.writeFieldBegin('alprSettings', TType.STRUCT, 6)
            self.alprSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionSession(object):
    """
    Detection session descriptor

    Attributes:
     - id: A unique id of the session
     - detectionSettings: Detection settings for the session

    """


    def __init__(self, id=None, detectionSettings=None,):
        self.id = id
        self.detectionSettings = detectionSettings

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.detectionSettings = DetectionSettings()
                    self.detectionSettings.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionSession')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I32, 1)
            oprot.writeI32(self.id)
            oprot.writeFieldEnd()
        if self.detectionSettings is not None:
            oprot.writeFieldBegin('detectionSettings', TType.STRUCT, 2)
            self.detectionSettings.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RawImageInput(object):
    """
    Raw image input

    Attributes:
     - width: width of image
     - height: height of image
     - format: image pixel format
     - buffer: image buffer

    """


    def __init__(self, width=None, height=None, format=None, buffer=None,):
        self.width = width
        self.height = height
        self.format = format
        self.buffer = buffer

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.width = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.height = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RawImageInput')
        if self.width is not None:
            oprot.writeFieldBegin('width', TType.I16, 1)
            oprot.writeI16(self.width)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I16, 2)
            oprot.writeI16(self.height)
            oprot.writeFieldEnd()
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.I32, 3)
            oprot.writeI32(self.format)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 4)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class EncodedImageInput(object):
    """
    Encoded image input

    Attributes:
     - format: encoding format of image
     - buffer: encoded image buffer
     - bufferLength: buffer length

    """


    def __init__(self, format=None, buffer=None, bufferLength=None,):
        self.format = format
        self.buffer = buffer
        self.bufferLength = bufferLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.buffer = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.bufferLength = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('EncodedImageInput')
        if self.format is not None:
            oprot.writeFieldBegin('format', TType.I32, 1)
            oprot.writeI32(self.format)
            oprot.writeFieldEnd()
        if self.buffer is not None:
            oprot.writeFieldBegin('buffer', TType.STRING, 2)
            oprot.writeBinary(self.buffer)
            oprot.writeFieldEnd()
        if self.bufferLength is not None:
            oprot.writeFieldBegin('bufferLength', TType.I32, 3)
            oprot.writeI32(self.bufferLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ImageFileInput(object):
    """
    Image file based input

    Attributes:
     - filename: path to image file

    """


    def __init__(self, filename=None,):
        self.filename = filename

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ImageFileInput')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class VideoFileInput(object):
    """
    Video file based input

    Attributes:
     - filename: path to video file
     - processFps: processing FPS for video (max 10)

    """


    def __init__(self, filename=None, processFps=None,):
        self.filename = filename
        self.processFps = processFps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.filename = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.processFps = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('VideoFileInput')
        if self.filename is not None:
            oprot.writeFieldBegin('filename', TType.STRING, 1)
            oprot.writeString(self.filename.encode('utf-8') if sys.version_info[0] == 2 else self.filename)
            oprot.writeFieldEnd()
        if self.processFps is not None:
            oprot.writeFieldBegin('processFps', TType.I32, 2)
            oprot.writeI32(self.processFps)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class InputParams(object):
    """
    Media input for detection

    Attributes:
     - rawImageInput: raw pixel image
     - encImageInput: encoded image
     - imgFileInput: image file input
     - vidFileInput: video file input

    """


    def __init__(self, rawImageInput=None, encImageInput=None, imgFileInput=None, vidFileInput=None,):
        self.rawImageInput = rawImageInput
        self.encImageInput = encImageInput
        self.imgFileInput = imgFileInput
        self.vidFileInput = vidFileInput

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rawImageInput = RawImageInput()
                    self.rawImageInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.encImageInput = EncodedImageInput()
                    self.encImageInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.imgFileInput = ImageFileInput()
                    self.imgFileInput.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.vidFileInput = VideoFileInput()
                    self.vidFileInput.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('InputParams')
        if self.rawImageInput is not None:
            oprot.writeFieldBegin('rawImageInput', TType.STRUCT, 1)
            self.rawImageInput.write(oprot)
            oprot.writeFieldEnd()
        if self.encImageInput is not None:
            oprot.writeFieldBegin('encImageInput', TType.STRUCT, 2)
            self.encImageInput.write(oprot)
            oprot.writeFieldEnd()
        if self.imgFileInput is not None:
            oprot.writeFieldBegin('imgFileInput', TType.STRUCT, 3)
            self.imgFileInput.write(oprot)
            oprot.writeFieldEnd()
        if self.vidFileInput is not None:
            oprot.writeFieldBegin('vidFileInput', TType.STRUCT, 4)
            self.vidFileInput.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionInput(object):
    """
    Detection input

    Attributes:
     - type: detection input type
     - params: detection input params

    """


    def __init__(self, type=None, params=None,):
        self.type = type
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.params = InputParams()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionInput')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 2)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectedObject(object):
    """
    Detected object descriptor

    Attributes:
     - name: friendly name of detected object
     - objectId: unique object id for object within session
     - top: top-left y co-ordinate normalized [0,1]
     - left: top-left x co-ordinate normalized [0,1]
     - bottom: bottom-right y co-ordinate normalized [0,1]
     - right: bottom-right x co-ordinate normalized [0,1]
     - frameIndex: index of frame (for videos) where object was detected
     - confidence: confidence score of detection [0, 1]
     - direction: line cross direction (if applicable)

    """


    def __init__(self, name=None, objectId=None, top=None, left=None, bottom=None, right=None, frameIndex=None, confidence=None, direction=None,):
        self.name = name
        self.objectId = objectId
        self.top = top
        self.left = left
        self.bottom = bottom
        self.right = right
        self.frameIndex = frameIndex
        self.confidence = confidence
        self.direction = direction

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.objectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.top = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.left = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.bottom = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.right = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.frameIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectedObject')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.objectId is not None:
            oprot.writeFieldBegin('objectId', TType.I32, 2)
            oprot.writeI32(self.objectId)
            oprot.writeFieldEnd()
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.DOUBLE, 3)
            oprot.writeDouble(self.top)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.DOUBLE, 4)
            oprot.writeDouble(self.left)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.DOUBLE, 5)
            oprot.writeDouble(self.bottom)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.DOUBLE, 6)
            oprot.writeDouble(self.right)
            oprot.writeFieldEnd()
        if self.frameIndex is not None:
            oprot.writeFieldBegin('frameIndex', TType.I32, 7)
            oprot.writeI32(self.frameIndex)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 8)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 9)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ObjectDetectionResult(object):
    """
    Object detection result

    Attributes:
     - objects: list of detected objects

    """


    def __init__(self, objects=None,):
        self.objects = objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = DetectedObject()
                        _elem33.read(iprot)
                        self.objects.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ObjectDetectionResult')
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.objects))
            for iter34 in self.objects:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceViolation(object):
    """
    Social distancing violation instance - detected object pair in violation

    Attributes:
     - first
     - second

    """


    def __init__(self, first=None, second=None,):
        self.first = first
        self.second = second

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.first = DetectedObject()
                    self.first.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.second = DetectedObject()
                    self.second.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceViolation')
        if self.first is not None:
            oprot.writeFieldBegin('first', TType.STRUCT, 1)
            self.first.write(oprot)
            oprot.writeFieldEnd()
        if self.second is not None:
            oprot.writeFieldBegin('second', TType.STRUCT, 2)
            self.second.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SocialDistanceResult(object):
    """
    Social distancing violation results

    Attributes:
     - violations: list of social distancing violations

    """


    def __init__(self, violations=None,):
        self.violations = violations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.violations = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = SocialDistanceViolation()
                        _elem40.read(iprot)
                        self.violations.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SocialDistanceResult')
        if self.violations is not None:
            oprot.writeFieldBegin('violations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.violations))
            for iter41 in self.violations:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossViolation(object):
    """
    Line cross violation instance

    Attributes:
     - first: object position before crossing
     - second: object position after crossing

    """


    def __init__(self, first=None, second=None,):
        self.first = first
        self.second = second

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.first = DetectedObject()
                    self.first.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.second = DetectedObject()
                    self.second.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossViolation')
        if self.first is not None:
            oprot.writeFieldBegin('first', TType.STRUCT, 1)
            self.first.write(oprot)
            oprot.writeFieldEnd()
        if self.second is not None:
            oprot.writeFieldBegin('second', TType.STRUCT, 2)
            self.second.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LineCrossDetectionResult(object):
    """
    Line cross detection results

    Attributes:
     - violations: list of line cross violations

    """


    def __init__(self, violations=None,):
        self.violations = violations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.violations = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = LineCrossViolation()
                        _elem47.read(iprot)
                        self.violations.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LineCrossDetectionResult')
        if self.violations is not None:
            oprot.writeFieldBegin('violations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.violations))
            for iter48 in self.violations:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class MaskDetectionResult(object):
    """
    Mask detection results

    Attributes:
     - objects: list of mask (violations and compliant) objects

    """


    def __init__(self, objects=None,):
        self.objects = objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = DetectedObject()
                        _elem54.read(iprot)
                        self.objects.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('MaskDetectionResult')
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.objects))
            for iter55 in self.objects:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectedText(object):
    """
    Detected Text descriptor

    Attributes:
     - text: detected text in utf-8 encoding
     - topLeftY: top-left y co-ordinate normalized [0,1]
     - topLeftX: top-left x co-ordinate normalized [0,1]
     - topRightY: top-right y co-ordinate normalized [0,1]
     - topRightX: top-right x co-ordinate normalized [0,1]
     - bottomRightY: bottom-right y co-ordinate normalized [0,1]
     - bottomRightX: bottom-right x co-ordinate normalized [0,1]
     - bottomLeftY: bottom-left y co-ordinate normalized [0,1]
     - bottomLeftX: bottom-left x co-ordinate normalized [0,1]
     - confidence: confidence score of detection [0, 1]

    """


    def __init__(self, text=None, topLeftY=None, topLeftX=None, topRightY=None, topRightX=None, bottomRightY=None, bottomRightX=None, bottomLeftY=None, bottomLeftX=None, confidence=None,):
        self.text = text
        self.topLeftY = topLeftY
        self.topLeftX = topLeftX
        self.topRightY = topRightY
        self.topRightX = topRightX
        self.bottomRightY = bottomRightY
        self.bottomRightX = bottomRightX
        self.bottomLeftY = bottomLeftY
        self.bottomLeftX = bottomLeftX
        self.confidence = confidence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.text = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.topLeftY = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.topLeftX = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.topRightY = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.topRightX = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.bottomRightY = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.bottomRightX = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.bottomLeftY = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.bottomLeftX = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectedText')
        if self.text is not None:
            oprot.writeFieldBegin('text', TType.STRING, 1)
            oprot.writeString(self.text.encode('utf-8') if sys.version_info[0] == 2 else self.text)
            oprot.writeFieldEnd()
        if self.topLeftY is not None:
            oprot.writeFieldBegin('topLeftY', TType.DOUBLE, 2)
            oprot.writeDouble(self.topLeftY)
            oprot.writeFieldEnd()
        if self.topLeftX is not None:
            oprot.writeFieldBegin('topLeftX', TType.DOUBLE, 3)
            oprot.writeDouble(self.topLeftX)
            oprot.writeFieldEnd()
        if self.topRightY is not None:
            oprot.writeFieldBegin('topRightY', TType.DOUBLE, 4)
            oprot.writeDouble(self.topRightY)
            oprot.writeFieldEnd()
        if self.topRightX is not None:
            oprot.writeFieldBegin('topRightX', TType.DOUBLE, 5)
            oprot.writeDouble(self.topRightX)
            oprot.writeFieldEnd()
        if self.bottomRightY is not None:
            oprot.writeFieldBegin('bottomRightY', TType.DOUBLE, 6)
            oprot.writeDouble(self.bottomRightY)
            oprot.writeFieldEnd()
        if self.bottomRightX is not None:
            oprot.writeFieldBegin('bottomRightX', TType.DOUBLE, 7)
            oprot.writeDouble(self.bottomRightX)
            oprot.writeFieldEnd()
        if self.bottomLeftY is not None:
            oprot.writeFieldBegin('bottomLeftY', TType.DOUBLE, 8)
            oprot.writeDouble(self.bottomLeftY)
            oprot.writeFieldEnd()
        if self.bottomLeftX is not None:
            oprot.writeFieldBegin('bottomLeftX', TType.DOUBLE, 9)
            oprot.writeDouble(self.bottomLeftX)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 10)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LicensePlateNumber(object):
    """
    License Plate Number descriptor

    Attributes:
     - plate: license plate number in utf-8 encoding
     - confidence: confidence of detection [0, 1]

    """


    def __init__(self, plate=None, confidence=None,):
        self.plate = plate
        self.confidence = confidence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.plate = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LicensePlateNumber')
        if self.plate is not None:
            oprot.writeFieldBegin('plate', TType.STRING, 1)
            oprot.writeString(self.plate.encode('utf-8') if sys.version_info[0] == 2 else self.plate)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 2)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class LicensePlate(object):
    """
    License plate descriptor

    Attributes:
     - detections: license plate number detections for this plate
     - objectId: unique object id for object within session
     - top: top-left y co-ordinate normalized [0,1]
     - left: top-left x co-ordinate normalized [0,1]
     - bottom: bottom-right y co-ordinate normalized [0,1]
     - right: bottom-right x co-ordinate normalized [0,1]
     - frameIndex: index of frame (for videos) where object was detected
     - confidence: confidence of detection score [0, 1]
     - associatedText: associated text found with license plate

    """


    def __init__(self, detections=None, objectId=None, top=None, left=None, bottom=None, right=None, frameIndex=None, confidence=None, associatedText=None,):
        self.detections = detections
        self.objectId = objectId
        self.top = top
        self.left = left
        self.bottom = bottom
        self.right = right
        self.frameIndex = frameIndex
        self.confidence = confidence
        self.associatedText = associatedText

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.detections = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = LicensePlateNumber()
                        _elem61.read(iprot)
                        self.detections.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.objectId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.top = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.left = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.bottom = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.right = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.frameIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.confidence = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.associatedText = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = DetectedText()
                        _elem67.read(iprot)
                        self.associatedText.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('LicensePlate')
        if self.detections is not None:
            oprot.writeFieldBegin('detections', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.detections))
            for iter68 in self.detections:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.objectId is not None:
            oprot.writeFieldBegin('objectId', TType.I32, 2)
            oprot.writeI32(self.objectId)
            oprot.writeFieldEnd()
        if self.top is not None:
            oprot.writeFieldBegin('top', TType.DOUBLE, 3)
            oprot.writeDouble(self.top)
            oprot.writeFieldEnd()
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.DOUBLE, 4)
            oprot.writeDouble(self.left)
            oprot.writeFieldEnd()
        if self.bottom is not None:
            oprot.writeFieldBegin('bottom', TType.DOUBLE, 5)
            oprot.writeDouble(self.bottom)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.DOUBLE, 6)
            oprot.writeDouble(self.right)
            oprot.writeFieldEnd()
        if self.frameIndex is not None:
            oprot.writeFieldBegin('frameIndex', TType.I32, 7)
            oprot.writeI32(self.frameIndex)
            oprot.writeFieldEnd()
        if self.confidence is not None:
            oprot.writeFieldBegin('confidence', TType.DOUBLE, 8)
            oprot.writeDouble(self.confidence)
            oprot.writeFieldEnd()
        if self.associatedText is not None:
            oprot.writeFieldBegin('associatedText', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.associatedText))
            for iter69 in self.associatedText:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class AlprResult(object):
    """
    ALPR results

    Attributes:
     - objects: list of ALPR detections

    """


    def __init__(self, objects=None,):
        self.objects = objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.objects = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = LicensePlate()
                        _elem75.read(iprot)
                        self.objects.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('AlprResult')
        if self.objects is not None:
            oprot.writeFieldBegin('objects', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.objects))
            for iter76 in self.objects:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class DetectionOutput(object):
    """
    Detection output descriptor

    Attributes:
     - status: Detection status code
     - objDetResult: object detections
     - socialDetResult: social distancing violations
     - lineCrossResult: line crossing detections
     - maskDetResult: mask detections
     - alprResult: ALPR detections

    """


    def __init__(self, status=None, objDetResult=None, socialDetResult=None, lineCrossResult=None, maskDetResult=None, alprResult=None,):
        self.status = status
        self.objDetResult = objDetResult
        self.socialDetResult = socialDetResult
        self.lineCrossResult = lineCrossResult
        self.maskDetResult = maskDetResult
        self.alprResult = alprResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.objDetResult = ObjectDetectionResult()
                    self.objDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.socialDetResult = SocialDistanceResult()
                    self.socialDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.lineCrossResult = LineCrossDetectionResult()
                    self.lineCrossResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.maskDetResult = MaskDetectionResult()
                    self.maskDetResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.alprResult = AlprResult()
                    self.alprResult.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('DetectionOutput')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.I32, 1)
            oprot.writeI32(self.status)
            oprot.writeFieldEnd()
        if self.objDetResult is not None:
            oprot.writeFieldBegin('objDetResult', TType.STRUCT, 2)
            self.objDetResult.write(oprot)
            oprot.writeFieldEnd()
        if self.socialDetResult is not None:
            oprot.writeFieldBegin('socialDetResult', TType.STRUCT, 3)
            self.socialDetResult.write(oprot)
            oprot.writeFieldEnd()
        if self.lineCrossResult is not None:
            oprot.writeFieldBegin('lineCrossResult', TType.STRUCT, 4)
            self.lineCrossResult.write(oprot)
            oprot.writeFieldEnd()
        if self.maskDetResult is not None:
            oprot.writeFieldBegin('maskDetResult', TType.STRUCT, 5)
            self.maskDetResult.write(oprot)
            oprot.writeFieldEnd()
        if self.alprResult is not None:
            oprot.writeFieldBegin('alprResult', TType.STRUCT, 6)
            self.alprResult.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(InitRequest)
InitRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'license', 'UTF8', None, ),  # 1
)
all_structs.append(DetectionCapability)
DetectionCapability.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'numConcurrentSessions', None, None, ),  # 1
)
all_structs.append(DetectorStatus)
DetectorStatus.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'apiVersion', 'UTF8', None, ),  # 2
    (3, TType.I32, 'initStatus', None, None, ),  # 3
    (4, TType.STRUCT, 'capability', [DetectionCapability, None], None, ),  # 4
    (5, TType.STRING, 'activationChallenge', 'UTF8', None, ),  # 5
)
all_structs.append(ObjectDetectionSettings)
ObjectDetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.I32, 'env', None, None, ),  # 2
    (3, TType.I32, 'objectType', None, None, ),  # 3
    (4, TType.BOOL, 'detectOnlyMovingObjects', None, None, ),  # 4
)
all_structs.append(DetectionArea)
DetectionArea.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'top', None, None, ),  # 1
    (2, TType.DOUBLE, 'left', None, None, ),  # 2
    (3, TType.DOUBLE, 'bottom', None, None, ),  # 3
    (4, TType.DOUBLE, 'right', None, None, ),  # 4
    (5, TType.STRING, 'name', 'UTF8', None, ),  # 5
)
all_structs.append(DetectionAreaSettings)
DetectionAreaSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'areas', (TType.STRUCT, [DetectionArea, None], False), None, ),  # 2
)
all_structs.append(NormPoint)
NormPoint.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'x', None, None, ),  # 1
    (2, TType.DOUBLE, 'y', None, None, ),  # 2
)
all_structs.append(SocialDistanceSettings)
SocialDistanceSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'groundBoundary', (TType.STRUCT, [NormPoint, None], False), None, ),  # 2
    (3, TType.LIST, 'minSeparation', (TType.STRUCT, [NormPoint, None], False), None, ),  # 3
)
all_structs.append(LineCrossSettings)
LineCrossSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.LIST, 'boundary', (TType.STRUCT, [NormPoint, None], False), None, ),  # 2
    (3, TType.STRUCT, 'inPoint', [NormPoint, None], None, ),  # 3
    (4, TType.I32, 'crossCriteria', None, None, ),  # 4
)
all_structs.append(MaskDetectionSettings)
MaskDetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
)
all_structs.append(AlprSettings)
AlprSettings.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'enabled', None, None, ),  # 1
    (2, TType.STRING, 'region', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'skipVehicleCheck', None, None, ),  # 3
    (4, TType.STRING, 'presetMode', 'UTF8', None, ),  # 4
)
all_structs.append(DetectionSettings)
DetectionSettings.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'objSettings', [ObjectDetectionSettings, None], None, ),  # 1
    (2, TType.STRUCT, 'sdSettings', [SocialDistanceSettings, None], None, ),  # 2
    (3, TType.STRUCT, 'detAreaSettings', [DetectionAreaSettings, None], None, ),  # 3
    (4, TType.STRUCT, 'lineCrossSettings', [LineCrossSettings, None], None, ),  # 4
    (5, TType.STRUCT, 'maskSettings', [MaskDetectionSettings, None], None, ),  # 5
    (6, TType.STRUCT, 'alprSettings', [AlprSettings, None], None, ),  # 6
)
all_structs.append(DetectionSession)
DetectionSession.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'id', None, None, ),  # 1
    (2, TType.STRUCT, 'detectionSettings', [DetectionSettings, None], None, ),  # 2
)
all_structs.append(RawImageInput)
RawImageInput.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'width', None, None, ),  # 1
    (2, TType.I16, 'height', None, None, ),  # 2
    (3, TType.I32, 'format', None, None, ),  # 3
    (4, TType.STRING, 'buffer', 'BINARY', None, ),  # 4
)
all_structs.append(EncodedImageInput)
EncodedImageInput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'format', None, None, ),  # 1
    (2, TType.STRING, 'buffer', 'BINARY', None, ),  # 2
    (3, TType.I32, 'bufferLength', None, None, ),  # 3
)
all_structs.append(ImageFileInput)
ImageFileInput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
)
all_structs.append(VideoFileInput)
VideoFileInput.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'filename', 'UTF8', None, ),  # 1
    (2, TType.I32, 'processFps', None, None, ),  # 2
)
all_structs.append(InputParams)
InputParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'rawImageInput', [RawImageInput, None], None, ),  # 1
    (2, TType.STRUCT, 'encImageInput', [EncodedImageInput, None], None, ),  # 2
    (3, TType.STRUCT, 'imgFileInput', [ImageFileInput, None], None, ),  # 3
    (4, TType.STRUCT, 'vidFileInput', [VideoFileInput, None], None, ),  # 4
)
all_structs.append(DetectionInput)
DetectionInput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'params', [InputParams, None], None, ),  # 2
)
all_structs.append(DetectedObject)
DetectedObject.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.I32, 'objectId', None, None, ),  # 2
    (3, TType.DOUBLE, 'top', None, None, ),  # 3
    (4, TType.DOUBLE, 'left', None, None, ),  # 4
    (5, TType.DOUBLE, 'bottom', None, None, ),  # 5
    (6, TType.DOUBLE, 'right', None, None, ),  # 6
    (7, TType.I32, 'frameIndex', None, None, ),  # 7
    (8, TType.DOUBLE, 'confidence', None, None, ),  # 8
    (9, TType.I32, 'direction', None, None, ),  # 9
)
all_structs.append(ObjectDetectionResult)
ObjectDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'objects', (TType.STRUCT, [DetectedObject, None], False), None, ),  # 1
)
all_structs.append(SocialDistanceViolation)
SocialDistanceViolation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'first', [DetectedObject, None], None, ),  # 1
    (2, TType.STRUCT, 'second', [DetectedObject, None], None, ),  # 2
)
all_structs.append(SocialDistanceResult)
SocialDistanceResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'violations', (TType.STRUCT, [SocialDistanceViolation, None], False), None, ),  # 1
)
all_structs.append(LineCrossViolation)
LineCrossViolation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'first', [DetectedObject, None], None, ),  # 1
    (2, TType.STRUCT, 'second', [DetectedObject, None], None, ),  # 2
)
all_structs.append(LineCrossDetectionResult)
LineCrossDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'violations', (TType.STRUCT, [LineCrossViolation, None], False), None, ),  # 1
)
all_structs.append(MaskDetectionResult)
MaskDetectionResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'objects', (TType.STRUCT, [DetectedObject, None], False), None, ),  # 1
)
all_structs.append(DetectedText)
DetectedText.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'text', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'topLeftY', None, None, ),  # 2
    (3, TType.DOUBLE, 'topLeftX', None, None, ),  # 3
    (4, TType.DOUBLE, 'topRightY', None, None, ),  # 4
    (5, TType.DOUBLE, 'topRightX', None, None, ),  # 5
    (6, TType.DOUBLE, 'bottomRightY', None, None, ),  # 6
    (7, TType.DOUBLE, 'bottomRightX', None, None, ),  # 7
    (8, TType.DOUBLE, 'bottomLeftY', None, None, ),  # 8
    (9, TType.DOUBLE, 'bottomLeftX', None, None, ),  # 9
    (10, TType.DOUBLE, 'confidence', None, None, ),  # 10
)
all_structs.append(LicensePlateNumber)
LicensePlateNumber.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'plate', 'UTF8', None, ),  # 1
    (2, TType.DOUBLE, 'confidence', None, None, ),  # 2
)
all_structs.append(LicensePlate)
LicensePlate.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'detections', (TType.STRUCT, [LicensePlateNumber, None], False), None, ),  # 1
    (2, TType.I32, 'objectId', None, None, ),  # 2
    (3, TType.DOUBLE, 'top', None, None, ),  # 3
    (4, TType.DOUBLE, 'left', None, None, ),  # 4
    (5, TType.DOUBLE, 'bottom', None, None, ),  # 5
    (6, TType.DOUBLE, 'right', None, None, ),  # 6
    (7, TType.I32, 'frameIndex', None, None, ),  # 7
    (8, TType.DOUBLE, 'confidence', None, None, ),  # 8
    (9, TType.LIST, 'associatedText', (TType.STRUCT, [DetectedText, None], False), None, ),  # 9
)
all_structs.append(AlprResult)
AlprResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'objects', (TType.STRUCT, [LicensePlate, None], False), None, ),  # 1
)
all_structs.append(DetectionOutput)
DetectionOutput.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'status', None, None, ),  # 1
    (2, TType.STRUCT, 'objDetResult', [ObjectDetectionResult, None], None, ),  # 2
    (3, TType.STRUCT, 'socialDetResult', [SocialDistanceResult, None], None, ),  # 3
    (4, TType.STRUCT, 'lineCrossResult', [LineCrossDetectionResult, None], None, ),  # 4
    (5, TType.STRUCT, 'maskDetResult', [MaskDetectionResult, None], None, ),  # 5
    (6, TType.STRUCT, 'alprResult', [AlprResult, None], None, ),  # 6
)
fix_spec(all_structs)
del all_structs
